<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>用十年来学编程 | 上五楼的快活</title><meta name="description" content="用十年来学编程"><meta name="keywords" content="转载"><meta name="author" content="Liu Ning,realliuning1995@gmail.com"><meta name="copyright" content="Liu Ning"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lnlynn.github.io/2018/02/25/reprint/program-in-ten-years/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="用十年来学编程"><meta name="twitter:description" content="用十年来学编程"><meta name="twitter:image" content="http://lnlynn.github.io/images/header_img/header-6.jpg"><meta property="og:type" content="article"><meta property="og:title" content="用十年来学编程"><meta property="og:url" content="http://lnlynn.github.io/2018/02/25/reprint/program-in-ten-years/"><meta property="og:site_name" content="上五楼的快活"><meta property="og:description" content="用十年来学编程"><meta property="og:image" content="http://lnlynn.github.io/images/header_img/header-6.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Java知识总结" href="http://lnlynn.github.io/2018/03/18/java/summary-of-java/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><div id="content-outer"><div id="top-container" style="background-image: url(/images/header_img/header-6.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">上五楼的快活</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/images/ironman-draw.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-file-photo-o"></i><span> 相册</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-bars"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">用十年来学编程</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-25</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/转载/">转载</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3><span id="为什么每个人都这么着急">为什么每个人都这么着急？</span></h3>
<p>走进任何一家书店，你会看到名为《如何在 24 小时内学会 Java》的书，还有各 种各样类似的书： 在几天内或几小时内学会 C，SQL，Ruby，算法等等，一眼望不到 尽头。我在 Amazon 上做了如下的高级检索 ：[<a href="http://www.amazon.com/gp/search/ref=sr_adv_b/?search-alias=stripbooks&amp;unfiltered=1&amp;field-keywords=&amp;field-author=&amp;field-title=teach+yourself+hours&amp;field-isbn=&amp;field-publisher=&amp;node=&amp;field-p_n_condition-type=&amp;field-feature_browse-bin=&amp;field-subject=&amp;field-language=&amp;field-dateop=After&amp;field-datemod=&amp;field-dateyear=2000&amp;sort=relevanceexprank&amp;Adv-Srch-Books-Submit.x=16&amp;Adv-Srch-Books-Submit.y=5" target="_blank" rel="noopener">title: teach, yourself, hours, since: 2000</a> ]得到了512 本这样的书。在前十本中有九本是关于编程的书（其它的是关于记账的）。把 “teach yourself” 换成 “learn” 或者用 “hours” 换成 “days”，可以得到了类似的结果。</p>
<p>从上面的搜索结果可以看出来，要么就是人们对计算机技术的学习如饥似渴，要么就是计算机技术实在太简单，不费吹灰之力就能学会。Felleisen 以及其它人在他们的著作<a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html" target="_blank" rel="noopener">《如何设计程序》</a>一书中明确指出了这种“速成”的趋势，并评论到：“垃圾的编程技术当然非常容易，傻子都能在 21 天之内学会，哪怕他天生就是个白痴。” Abtruse Goose 的漫画中也有<a href="http://abstrusegoose.com/249" target="_blank" rel="noopener">类似尝试</a>。</p>
<p>让我们分析一下，像一本名为《<strong>24 小时内学会 C++</strong>》的书意味着什么：</p>
<ul>
<li><strong>学习：</strong> 在 24 小时里，你没有时间写一些重大的程序，并从成功或失败中得益。你没有时间与有经验的程序员合作，并理解在 C++ 的环境下工作是怎么回事。一句话，你不会有时间学到太多东西。因此他们只能谈论一些肤浅的东西，而不是深入的理解。正如亚历山大教皇所说，浅尝辄止是危险的事情。</li>
<li><strong>C++：</strong> 在 24小时的时间里，你可能学会 C++ 的语法（如果你 已经学过类似的语言），但你学不到更多的如何使用这些语法的知识。也就是说， 假如你曾是个 BASIC  程序员，你可以学着用 C++ 语法写出 BASIC 风格的程序，但你不可能了解 C++ 真正的好处（和坏处）。那么关键是什么？ <strong>Alan Perlis</strong>说过：“一种不改变你编程的思维方式的语言，不值得去学。” 一种可 能的情况是：你必须学一点儿 C++（或可能性更大的像 JavaScript 或 Processing 之类），因为你为了完成某种特定的任务，需要与一个现存的工具建立接口。不过那不是学习如何编程，而是在学习如何完成那个任务。</li>
<li><strong>24 小时内：</strong> 很不幸，这不够，原因由下一节告诉我们。</li>
</ul>
<h3><span id="在十年里学会编程">在十年里学会编程</span></h3>
<p>研究人员在一系列调查显示，在各个领域内，要想获得专业级别的水平，大约需要 10 年时间的努力。参与此项调查的领域包括：国际象棋，作曲，发报，绘画，钢琴演奏，游泳，网球以及对神经心理学和拓扑学的研究。若要在某一领域内达到专家级的水平，其关键在于“<em>刻意</em>练习”，也就是说，并非是机械地，一遍又一遍地练习，而是要不断地挑战自我，试图超越自身当前的水平，通过不断的尝试挑战，并在尝试的过程中和尝试之后对自身的表现进行分析和总结，吸取经验，纠正之前犯过的各种错误。把这一过程不断重复，才能取得成功。所谓的“捷径”是不存在的，即使对于莫扎特这种天才来说，也没有捷径可走，尽管 4 岁就开始作曲，可是他也花了 13 年的时间，才真正地写出了世界级的作品。再举一个例子，甲壳虫乐队（<strong>The Beatles</strong>）,他们似乎在 1964 年凭借一系列热门单曲和其在艾德沙利文秀（The Ed Sullivan show）上的演出一炮而红，但是你也许不知道，他们早在 1957 年就在利物浦和汉堡两地进行小规模演出了，而在此之前的非正式演出更是不计其数。甲壳虫乐队的主要成名曲《<em>Sgt. Peppers</em>》，则是 1967 年才发行的。</p>
<p><strong>Malcolm Gladwell</strong>推广了这个理念，尽管他的重点在 10000 个小时而不是 10 年。Henri Cartier-Bresson(1908-2004)说过，“你所拍摄的头 10000 张照片都是最糟糕的”。（他没有预料到，有了数码相机后，有些人可以在一周内达到这个数量~）真正的专业或许需要花费一生的时间。Samuel Johnson (塞缪尔 约翰逊 1709-1784)说：“在任何一个领域要想做到极好,势必穷尽一生的精力，否则根本无法企及。” Chaucer (乔叟 1340-1400)也发出过“生命如此短暂，技能如此高深”的感叹。Hippocrates (希波克拉底，约 400BC)因写下了如下的句子而被人称颂：“ars longa, vita brevis”，该句是来自于一个更长的引用：”Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, 这段话（拉丁文）翻译成英语就是：“<strong>生命很短暂，但是技艺却很高深，机遇转瞬即逝，探索难以捉摸，抉择困难重重</strong>”。</p>
<p>显然，没有一个单一的数字可以作为最终的回答：假定所有技能（比如编程，国际象棋，跳棋，音乐）都需要相同的时间来成为专家或者假定任何人都需要一样的时间是没理由的。正如<strong>K. Anders Ericsson</strong>教授所指出的那样：“在绝大多数领域，哪怕是最有天分的个人，他们达到最高水平所耗费的时间也是极为显著的。10000 小时这个数字只是想让你意识到即便是人们口中的那些最具天赋的个体想达到最高水平也需要年复一年的每周花上 10 到 20 小时。”</p>
<h3><span id="你想当程序员么">你想当程序员么？</span></h3>
<p>这是我为编程成功开出的方子：</p>
<ul>
<li><strong>对编程感兴趣</strong>，并且因为它有趣而编一些程序。确保编程一直充满足够乐趣，这样你才愿意投入十年/10000 小时宝贵时间。</li>
<li><strong>写程序</strong>。 最好的学习方式是从实践中学习。 用更技术性的话说，“在一个给定的领域内，个人的最大能力不 是自动地由扩展了的经验取得的，但即使是高度有经验的人也可以通过有意识的努力来提高自己的能力和 “最有效的学习需要因人而异的适当难度，目标明确的任务，丰富的信息反馈，以及重复的机会和错误修正。”此书 <em>Cognition in Practice: Mind，Mathematics，and Culture in Everyday Life</em> 是阐明此观点的令人感兴趣的参考文献。</li>
<li>与其他程序员<strong>交流</strong>； 阅读其它程序。这比任何书本或训练课程都重要。</li>
<li>如果愿意，在<strong>大学</strong>里呆上 4 年（或更长，在研究生院里）。你会接触到一些需要文凭的工作，你会对此领域有更深的理解。如果你不喜欢学校， 你可以（会有所牺牲）依靠自身或在工作中获得相似的经验。在任何情况下，光啃书本是不够的。Eric Raymond，<em>The New Hacker’s Dictionary</em> 一书的作者，说过，“计算机科学不能把任何人变成编程专家，就象光研究刷子和颜料不会使人变成画家一样。” 我雇佣过的最好的程序员之一仅有高中文凭；他做出了许多优秀的软件，有他自己的新闻组， 而且通过股票期权买到了自己的夜总会。</li>
<li>和其他程序员<strong>一起做项目</strong>。在其中的一些项目中作为最好的程序员； 而在另一些项目中是最差的。当你是最好的，你能测试领导项目的能力，用你 的观点激发别人。当你是最差的，你学习杰出者是怎么做的，了解他们不喜欢做 什么（因为他们吩咐你做事）。</li>
<li>在其他程序员<strong>之后接手项目</strong>。使自己理解别人写的程序。 当程序的原作者不在的时候，研究什么需要理解并且修改它。思考如何设计你的 程序以便后来者的维护。</li>
<li>学习至少半打的编程语言。包括一种支持类抽象的语言（像 Java  或 C++），一种支持函数化抽象的语言（像 Lisp 或 ML 或 Haskell），一种支持语法抽象的语言（像 Lisp），一种支持声明规格说明的语言（像 Prolog 或 C++ 的模板），以及那些强调并行的语言（像 Clojure 或 Go）。</li>
<li>请记住“计算机科学”中有“<strong>计算机</strong>”一词。了解你的计算机要花多 长时间执行一条指令，从内存中取一个字（有cache），从磁盘中读取连续的字， 和在磁盘中找到新的位置。</li>
<li>参与一种语言<strong>标准化</strong>的工作。它可以是 ANSI C++ 委员会， 也可以是决定你周围小范围内的编程风格是应该两个还是四个空格缩进。通过任何一种方式，你了解到其他人在某种语言中的想法，他们的理解深度，甚至一些他们这样想的原因。</li>
<li>具备良好的判断力，能尽快地从语言标准化的纠缠中<strong>脱身</strong>。</li>
</ul>
<p>明白了这些，仅从书本中你能得到多少就成了一个问题。在我第一个孩子出生前， 我读了所有的（关于育儿的）<em>How to</em> 书籍，仍然感觉是个手足无措的新手。30 个月以后，我 的第二个孩子快要出生了，我回头温习这些书了吗？ 没有。相反，我依靠我的个人 经验，它比专家写的数千页书更有用和可靠。</p>
<p>Fred Brooks在他的随笔《<strong>No Silver Bullet</strong>》 中定出了一个寻找优秀软件设计者的三步计划：</p>
<ol>
<li>尽可能早地，有系统地识别顶级的设计人员。</li>
<li>为设计人员指派一位职业导师，负责他们技术方面的成长，仔细地为他们规划 职业生涯。</li>
<li>为成长中的设计人员提供相互交流和学习的机会。</li>
</ol>
<p>此计划假设某些人已经具备了杰出设计者的必要才能； 要做的只是如何恰当地诱导他们。 <strong>Alan Perlis</strong>说得更简明扼要：“每个人都能被教会雕刻：对米开朗其罗而言， 反倒是告诉他哪些事不要做。同样的道理也适用于优秀的程序员。”</p>
<p>Perlis 认为，伟大的软件开发人员都有一种内在的特质，这种特质往往比他们所接受的训练更重要。但是这些特质是从哪里来的呢？是与生俱来的？还是通过后天勤奋而来？正如 Auguste Gusteau（动画电影《料理鼠王》里的幻象大厨）所说，“谁都能做饭，但只有那些无所畏惧的人才能成为大厨！”我把“将你生命中的大部分时间花在刻意练习上”更多视作为一种自愿！但或许“无所畏惧”才是概括它的方式。或者，就像是《料理鼠王》里那个与 Gusteau 作对的刻薄的美食评论家 Anton Ego 说的那样：“不是任何人都能成为伟大的艺术家，不过，伟大的艺术家可以来自任何地方。”</p>
<p>所以尽管买本 Java/Ruby/Javascript/PHP 的书吧。你可能会从中学到点儿东西。但作为一个程序员，你不会在 21 天内或 24 小时内改变你的人生，或你实际的水平。你尝试过连续 24 个月不懈努力提高自己么？如果你做到了，好吧，那么你开始上路了。</p>
<h3><span id="why-is-everyone-in-such-a-rush">Why is everyone in such a rush?</span></h3>
<blockquote>
<p>Walk into any bookstore, and you’ll see how to Teach Yourself Java in 24 Hours alongside endless variations offering to teach C, SQL, Ruby,Algorithms, and so on in a few days or hours. The Amazon advanced search for [title: teach, yourself, hours, since: <strong><em>2000 and found 512 such books</em></strong>. Of the top ten, nine are programming books (the other is about bookkeeping). Similar results come from replacing “teach yourself” with “learn” or “hours” with “days.”</p>
</blockquote>
<p>The conclusion is that either people are in a big rush to learn about programming, or that programming is somehow fabulously easier to learn than anything else. Felleisen et al. give a nod to this trend in their book How to Design Programs, when they say “Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.” The Abtruse Goose comic also had their take.</p>
<p>Let’s analyze what a title like Teach Yourself C++ in 24 Hours could mean:</p>
<ul>
<li>
<p><strong>Teach Yourself: In 24 hours you won’t have time to write several significant programs, and learn from your successes and failures with them. You won’t have time to work with an experienced programmer and understand what it is like to live in a C++ environment. In short, you won’t have time to learn much. So the book can only be talking about a superficial familiarity, not a deep understanding. As Alexander Pope said, a little learning is a dangerous thing.</strong></p>
</li>
<li>
<p><strong>C++: In 24 hours you might be able to learn some of the syntax of C++ (if you already know another language), but you couldn’t learn much about how to use the language. In short, if you were, say, a Basic programmer, you could learn to write programs in the style of Basic using C++ syntax, but you couldn’t learn what C++ is actually good (and bad) for. So what’s the point? Alan Perlis once said: “A language that doesn’t affect the way you think about programming, is not worth knowing”. One possible point is that you have to learn a tiny bit of C++ (or more likely, something like JavaScript or Processing) because you need to interface with an existing tool to accomplish a specific task. But then you’re not learning how to program; you’re learning to accomplish that task.</strong></p>
</li>
<li>
<p><strong>in 24 Hours: Unfortunately, this is not enough, as the next section shows.</strong></p>
</li>
</ul>
<h3><span id="teach-yourself-programming-in-ten-years">Teach Yourself Programming in Ten Years</span></h3>
<p>Researchers (Bloom (1985), Bryan &amp; Harter (1899), Hayes (1989), Simmon &amp; Chase (1973)) have shown it takes about ten years to develop expertise in any of a wide variety of areas, including chess playing, music composition, telegraph operation, painting, piano playing, swimming, tennis, and research in neuropsychology and topology. The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. There appear to be no real shortcuts: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967.</p>
<p>Malcolm Gladwell has popularized the idea, although he concentrates on 10,000 hours, not 10 years. Henri Cartier-Bresson (1908-2004) had another metric: “Your first 10,000 photographs are your worst.” (He didn’t anticipate that with digital cameras, some people can reach that mark in a week.) True expertise may take a lifetime: Samuel Johnson (1709-1784) said “Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.” And Chaucer (1340-1400) complained “the lyf so short, the craft so long to lerne.” Hippocrates (c. 400BC) is known for the excerpt “ars longa, vita brevis”, which is part of the longer quotation “Arslonga, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile”, which in English renders as “Life is short, [the] craft long, opportunity fleeting, experiment treacherous, judgment difficult.” Of course, no single number can be the final answer: it doesn’t seem reasonable to assume that all skills (e.g., programming, chess playing, checkers playing, and music playing) could all require exactly the same amount of time to master, nor that all people will take exactly the same amount of time. As Prof. K. Anders Ericsson puts it, “In most domains it’s remarkable how much time even the most talented individuals need in order to reach the highest levels of performance. The 10,000 hour number just gives you a sense that we’re talking years of 10 to 20 hours a week which those who some people would argue are the most innately talented individuals still need to get to the highest level.”</p>
<h3><span id="so-you-want-to-be-a-programmer">So You Want to be a Programmer</span></h3>
<p>Here’s my recipe for programming success:</p>
<ul>
<li>Get <strong>interested</strong> in programming, and do some because it is fun. Make sure that it keeps being enough fun so that you will be willing to put in your ten years/10,000 hours.</li>
<li><strong>Program</strong>. The best kind of learning is learning by doing. To put it more technically, “the maximal level of performance for individuals in a given domain is not attained automatically as a function of extended experience, but the level of performance can be increased even by highly experienced individuals as a result of deliberate efforts to improve.” (p. 366) and “the most effective learning requires a well-defined task with an appropriate difficulty level for the particular individual, informative feedback, and opportunities for repetition and corrections of errors.” (p. 20-21) The book Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life is an interesting reference for this viewpoint.</li>
<li><strong>Talk with other programmers; read other programs.</strong> This is more important than any book or training course.</li>
<li>If you want, put in four years at a <strong>college</strong> (or more at a graduate school). This will give you access to some jobs that require credentials, and it will give you a deeper understanding of the field, but if you don’t enjoy school, you can (with some dedication) get similar experience on your own or on the job. In any case, book learning alone won’t be enough. “Computer science education cannot make anybody an expert programmer any more than studying brushes and pigment can make somebody an expert painter” says Eric Raymond, author of The New Hacker’s Dictionary. One of the best programmers I ever hired had only a High School degree; he’s produced a lot of great software, has his own news group, and made enough in stock options to buy his own nightclub.</li>
<li><strong>Work on projects with other programmers.</strong> Be the best programmer on some projects; be the worst on some others. When you’re the best, you get to test your abilities to lead a project, and to inspire others with your vision. When you’re the worst, you learn what the masters do, and you learn what they don’t like to do (because they make you do it for them).</li>
<li><strong>Work on projects after other programmers.</strong> Understand a program written by someone else. See what it takes to understand and fix it when the original programmers are not around. Think about how to design your programs to make it easier for those who will maintain them after you.</li>
<li><strong>Learn at least a half dozen programming languages.</strong> Include one language that emphasizes class abstractions (like Java or C++), one that emphasizes functional abstraction (like Lisp or ML or Haskell), one that supports syntactic abstraction (like Lisp), one that supports declarative specifications (like Prolog or C++ templates), and one that emphasizes parallelism (like Clojure or Go).</li>
<li>Remember that there is a “<strong>computer</strong>” in “computer science”. Know how long it takes your computer to execute an instruction, fetch a word from memory (with and without a cache miss), read consecutive words from disk, and seek to a new location on disk. (Answers here.)</li>
<li>Get involved in a language <strong>standardization</strong> effort. It could be the ANSI C++ committee, or it could be deciding if your local coding style will have 2 or 4 space indentation levels. Either way, you learn about what other people like in a language, how deeply they feel so, and perhaps even a little about why they feel so.</li>
<li>Have the good sense to <strong>get off</strong> the language standardization effort as quickly as possible.</li>
</ul>
<p>With all that in mind, its questionable how far you can get just by book learning. Before my first child was born, I read all the How To books, and still felt like a clueless novice. 30 Months later, when my second child was due, did I go back to the books for a refresher? No. Instead, I relied on my personal experience, which turned out to be far more useful and reassuring to me than the thousands of pages written by experts.</p>
<p>Fred Brooks, in his essay No Silver Bullet identified a three-part plan for finding great software designers:</p>
<ol>
<li>Systematically identify top designers as early as possible.</li>
<li>Assign a career mentor to be responsible for the development of the prospect and carefully keep a career file.</li>
<li>Provide opportunities for growing designers to interact and stimulate each other.</li>
</ol>
<p>This assumes that some people already have the qualities necessary for being a great designer; the job is to properly coax them along. Alan Perlis put it more succinctly: “Everyone can be taught to sculpt: Michelangelo would have had to be taught how not to. So it is with the great programmers”. Perlis is saying that the greats have some internal quality that transcends their training. But where does the quality come from? Is it innate? Or do they develop it through diligence? As Auguste Gusteau (the fictional chef in Ratatouille) puts it, “anyone can cook, but only the fearless can be great.” I think of it more as willingness to devote a large portion of one’s life to deliberative practice. But maybe fearless is a way to summarize that. Or, as Gusteau’s critic, Anton Ego, says: “Not everyone can become a great artist, but a great artist can come from anywhere.”</p>
<p>So go ahead and buy that Java/Ruby/Javascript/PHP book; you’ll probably get some use out of it. But you won’t change your life, or your real overall expertise as a programmer in 24 hours or 21 days. How about working hard to continually improve over 24 months? Well, now you’re starting to get somewhere…</p>
<hr>
<h3><span id="references">References</span></h3>
<p>Bloom, Benjamin (ed.) Developing Talent in Young People, Ballantine, 1985.</p>
<p>Brooks, Fred, No Silver Bullets, IEEE Computer, vol. 20, no. 4, 1987, p. 10-19.</p>
<p>Bryan, W.L. &amp; Harter, N. &quot;Studies on the telegraphic language: The acquisition of a hierarchy of habits. Psychology Review, 1899, 8, 345-375</p>
<p>Hayes, John R., Complete Problem Solver Lawrence Erlbaum, 1989.</p>
<p>Chase, William G. &amp; Simon, Herbert A. “Perception in Chess” Cognitive Psychology, 1973, 4, 55-81.</p>
<p>Lave, Jean, Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life, Cambridge University Press, 1988.</p>
<hr>
<h3><span id="answers">Answers</span></h3>
<p>Approximate timing for various operations on a typical PC:</p>
<table>
<thead>
<tr>
<th style="text-align:left">options</th>
<th style="text-align:right">time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">execute typical instruction</td>
<td style="text-align:right">1/1,000,000,000 sec = 1 nanosec</td>
</tr>
<tr>
<td style="text-align:left">fetch from L1 cache memory</td>
<td style="text-align:right">0.5 nanosec</td>
</tr>
<tr>
<td style="text-align:left">branch misprediction</td>
<td style="text-align:right">5 nanosec</td>
</tr>
<tr>
<td style="text-align:left">fetch from L2 cache memory</td>
<td style="text-align:right">7 nanosec</td>
</tr>
<tr>
<td style="text-align:left">Mutex lock/unlock</td>
<td style="text-align:right">25 nanosec</td>
</tr>
<tr>
<td style="text-align:left">fetch from main memory</td>
<td style="text-align:right">100 nanosec</td>
</tr>
<tr>
<td style="text-align:left">send 2K bytes over 1Gbps network</td>
<td style="text-align:right">20,000 nanosec</td>
</tr>
<tr>
<td style="text-align:left">read 1MB sequentially from memory</td>
<td style="text-align:right">250,000 nanosec</td>
</tr>
<tr>
<td style="text-align:left">fetch from new disk location (seek)</td>
<td style="text-align:right">8,000,000 nanosec</td>
</tr>
<tr>
<td style="text-align:left">read 1MB sequentially from disk</td>
<td style="text-align:right">20,000,000 nanosec</td>
</tr>
<tr>
<td style="text-align:left">send packet US to Europe and back</td>
<td style="text-align:right">150 milliseconds = 150,000,000 nanosec</td>
</tr>
</tbody>
</table>
<hr>
<h3><span id="appendix-language-choice">Appendix: Language Choice</span></h3>
<p>Several people have asked what programming language they should learn first. There is no one answer, but consider these points:</p>
<ul>
<li><strong><em>Use your friends</em></strong>. When asked “what operating system should I use, Windows, Unix, or Mac?”, my answer is usually: “use whatever your friends use.” The advantage you get from learning from your friends will offset any intrinsic difference between OS, or between programming languages. Also consider your future friends: the community of programmers that you will be a part of if you continue. Does your chosen language have a large growing community or a small dying one? Are there books, web sites, and online forums to get answers from? Do you like the people in those forums?</li>
<li><strong><em>Keep it simple</em></strong>. Programming languages such as C++ and Java are designed for professional development by large teams of experienced programmers who are concerned about the run-time efficiency of their code. As a result, these languages have complicated parts designed for these circumstances. You’re concerned with learning to program. You don’t need that complication. You want a language that was designed to be easy to learn and remember by a single new programmer.</li>
<li><strong><em>Play</em></strong>. Which way would you rather learn to play the piano: the normal, interactive way, in which you hear each note as soon as you hit a key, or “batch” mode, in which you only hear the notes after you finish a whole song? Clearly, interactive mode makes learning easier for the piano, and also for programming. Insist on a language with an interactive mode and use it.</li>
</ul>
<p>Given these criteria, my recommendations for a first programming language would be Python or Scheme. Another choice is Javascript, not because it is perfectly well-designed for beginners, but because there are so many online tutorials for it, such as Khan Academy’s tutorial. But your circumstances may vary, and there are other good choices. If your age is a single-digit, you might prefer Alice or Squeak or Blockly (older learners might also enjoy these). The important thing is that you choose and get started.</p>
<hr>
<h3><span id="appendix-books-and-other-resources">Appendix: Books and Other Resources</span></h3>
<p>Several people have asked what books and web pages they should learn from. I repeat that “book learning alone won’t be enough” but I can recommend the following:</p>
<ul>
<li><strong><em>Scheme:</em></strong> Structure and Interpretation of Computer Programs (Abelson &amp; Sussman) is probably the best introduction to computer science, and it does teach programming as a way of understanding the computer science. You can see online videos of lectures on this book, as well as the complete text online. The book is challenging and will weed out some people who perhaps could be successful with another approach.</li>
<li><strong><em>Scheme:</em></strong> How to Design Programs (Felleisen et al.) is one of the best books on how to actually design programs in an elegant and functional way.</li>
<li><strong><em>Python:</em></strong> Python Programming: An Intro to CS (Zelle) is a good introduction using Python.</li>
<li><strong><em>Python:</em></strong> Several online tutorials are available at <a href="http://Python.org" target="_blank" rel="noopener">Python.org</a>.</li>
<li><strong><em>Oz:</em></strong> Concepts, Techniques, and Models of Computer Programming (Van Roy &amp; Haridi) is seen by some as the modern-day successor to Abelson &amp; Sussman. It is a tour through the big ideas of programming, covering a wider range than Abelson &amp; Sussman while being perhaps easier to read and follow. It uses a language, Oz, that is not widely known but serves as a basis for learning other languages.</li>
</ul>
<hr>
<h3><span id="notes">Notes</span></h3>
<p>T. Capey points out that the Complete Problem Solver page on Amazon now has the “Teach Yourself Bengali in 21 days” and “Teach Yourself Grammar and Style” books under the “Customers who shopped for this item also shopped for these items” section. I guess that a large portion of the people who look at that book are coming from this page. Thanks to Ross Cohen for help with Hippocrates.</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/转载/">转载    </a></div><div class="post_share"><div class="social-share" data-image="/images/header_img/header-6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2018/03/18/java/summary-of-java/"><img class="prev_cover lozad" data-src="/images/header_img/header-8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Java知识总结</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span>Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/08/13/reprint/ajax-and-fetch/" title="Ajxa已死，fetch永生"><img class="relatedPosts_cover lozad" data-src="/images/header_img/header-10.jpg"><div class="relatedPosts_title">Ajxa已死，fetch永生</div></a></div><div class="relatedPosts_item"><a href="/2018/03/18/reprint/aibaba/" title="一个从阿里面试回来的程序员的感想"><img class="relatedPosts_cover lozad" data-src="/images/header_img/header-1.jpg"><div class="relatedPosts_title">一个从阿里面试回来的程序员的感想</div></a></div><div class="relatedPosts_item"><a href="/2018/07/27/reprint/the-battle-between-intel-and-arm/" title="从Intel和ARM争霸战，看看做芯片有多难"><img class="relatedPosts_cover lozad" data-src="/images/header_img/header-7.jpg"><div class="relatedPosts_title">从Intel和ARM争霸战，看看做芯片有多难</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Liu Ning</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>