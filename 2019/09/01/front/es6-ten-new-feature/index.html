<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>前端开发者不得不知的ES6十大特性 | 上五楼的快活</title><meta name="description" content="前端开发者不得不知的ES6十大特性"><meta name="keywords" content="JavaScript"><meta name="author" content="Liu Ning,realliuning1995@gmail.com"><meta name="copyright" content="Liu Ning"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://lnlynn.github.io/2019/09/01/front/es6-ten-new-feature/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="前端开发者不得不知的ES6十大特性"><meta name="twitter:description" content="前端开发者不得不知的ES6十大特性"><meta name="twitter:image" content="http://lnlynn.github.io/images/header_img/header-1.jpg"><meta property="og:type" content="article"><meta property="og:title" content="前端开发者不得不知的ES6十大特性"><meta property="og:url" content="http://lnlynn.github.io/2019/09/01/front/es6-ten-new-feature/"><meta property="og:site_name" content="上五楼的快活"><meta property="og:description" content="前端开发者不得不知的ES6十大特性"><meta property="og:image" content="http://lnlynn.github.io/images/header_img/header-1.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Java线程池ThreadPoolExecutor入门" href="http://lnlynn.github.io/2019/12/29/java/java-threadpoolexecutor-introduce/"><link rel="next" title="HTML5新特性" href="http://lnlynn.github.io/2019/08/07/front/html5-new-feature/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight_copy: 'false',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><div id="content-outer"><div id="top-container" style="background-image: url(/images/header_img/header-1.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">上五楼的快活</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/images/ironman-draw.jpg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-file-photo-o"></i><span> 相册</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-bars"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">前端开发者不得不知的ES6十大特性</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-01</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/前端/">前端</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>ECMAScript 6（简称ES6）是JavaScript语言的下一代标准，已于2015年6月正式发布。它的目标是是使JavaScript语言可以用于编写复杂的大型应用程序，成为企业级开发语言。</p>
<p>ECMAScript是JavaScript的标准规范，由国际标准化组织负责制定，下面简要回顾下JavaScript的发展历史：</p>
<ul>
<li>
<p>1995年，JavaScript诞生，它的初始名叫LiveScript；</p>
</li>
<li>
<p>1997年，ECMAScript标准确立，并发布1.0版本；</p>
</li>
<li>
<p>1999年，ES3标准发布，此时IE5风靡一时；</p>
</li>
<li>
<p>2005年，AJAX在Google Maps上大放光彩，流行开来；</p>
</li>
<li>
<p>2009年，ES5标准发布，包括foreach、Object.keys和JSON标准等；</p>
</li>
<li>
<p>2015年，ES6制定完成。</p>
</li>
</ul>
<p>ES6带来了很多新特性，解决了ES5很多不足之处，让JavaScript代码更加规范，也让开发者更加优雅地编码。</p>
<p>以下是ES6排名前十的最佳特性列表（排名不分先后）：</p>
<ol>
<li><strong>Default Parameters</strong></li>
<li><strong>Template Literals</strong></li>
<li><strong>Multi-line Strings</strong></li>
<li><strong>Destructuring Assignment</strong></li>
<li><strong>Enhanced Object Literals</strong></li>
<li><strong>Arrow Functions</strong></li>
<li><strong>Promises</strong></li>
<li><strong>Block-Scoped Constructs Let and Const</strong></li>
<li><strong>Classes</strong></li>
<li><strong>Modules</strong></li>
</ol>
<h2><span id="1default-parameters默认参数">1.Default Parameters（默认参数）</span></h2>
<p>还记得我们以前不得不通过下面方式来定义默认参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span> (<span class="params">height, color, url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span>;</span><br><span class="line">    <span class="keyword">var</span> url = url || <span class="string">'http://azat.co'</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切工作都是正常的，直到参数值是0后，就有问题了，因为在JavaScript中，0表示fasly，它是默认被hard-coded的值，而不能变成参数本身的值。当然，如果你非要用0作为值，我们可以忽略这一缺陷并且使用逻辑OR就行了！但在ES6，我们可以直接把默认值放在函数申明里：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">'red'</span>, url = <span class="string">'http://azat.co'</span></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2template-literals模板对象">2.Template Literals（模板对象）</span></h2>
<p>在其它语言中，使用模板和插入值是在字符串里面输出变量的一种方式。因此，在ES5，我们可以这样组合一个字符串：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Your name is '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://localhost:3000/api/messages/'</span> + id;</span><br></pre></td></tr></table></figure>
<p>幸运的是，在ES6中，我们可以使用新的语法$ {NAME}，并把它放在反引号里：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>. `</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">`http://localhost:3000/api/messages/<span class="subst">$&#123;id&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="3multi-line-strings-多行字符串">3.Multi-line Strings （多行字符串）</span></h2>
<p>ES6的多行字符串是一个非常实用的功能。在ES5中，我们不得不使用以下方法来表示多行字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roadPoem = <span class="string">'Then took the other, as just as fair,nt'</span></span><br><span class="line">    + <span class="string">'And having perhaps the better claimnt'</span></span><br><span class="line">    + <span class="string">'Because it was grassy and wanted wear,nt'</span></span><br><span class="line">    + <span class="string">'Though as for that the passing therent'</span></span><br><span class="line">    + <span class="string">'Had worn them really about the same,nt'</span>;</span><br><span class="line"><span class="keyword">var</span> fourAgreements = <span class="string">'You have the right to be you.n</span></span><br><span class="line"><span class="string">    You can only be you when you do your best.'</span>;</span><br></pre></td></tr></table></figure>
<p>然而在ES6中，仅仅用反引号就可以解决了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roadPoem = `Then took the other, <span class="keyword">as</span> just <span class="keyword">as</span> fair,</span><br><span class="line">    <span class="keyword">And</span> having perhaps the better claim</span><br><span class="line">    Because it was grassy <span class="keyword">and</span> wanted wear,</span><br><span class="line">    Though <span class="keyword">as</span> <span class="keyword">for</span> that the passing there</span><br><span class="line">    Had worn them really about the same,`;</span><br><span class="line"><span class="keyword">var</span> fourAgreements = `You have the right to be you.</span><br><span class="line">    You can only be you when you <span class="keyword">do</span> your best.`;</span><br></pre></td></tr></table></figure>
<h2><span id="4destructuring-assignment-解构赋值">4.Destructuring Assignment （解构赋值）</span></h2>
<p>解构可能是一个比较难以掌握的概念。先从一个简单的赋值讲起，其中house 和 mouse是key，同时house 和mouse也是一个变量，在ES5中是这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = $(<span class="string">'body'</span>).data(), <span class="comment">// data has properties house and mouse</span></span><br><span class="line">   house = data.house,</span><br><span class="line">   mouse = data.mouse;</span><br></pre></td></tr></table></figure>
<p>以及在node.js中用ES5是这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'body-parser'</span>).jsonMiddleware ;</span><br><span class="line"><span class="keyword">var</span> body = req.body, <span class="comment">// body has username and password</span></span><br><span class="line">   username = body.username,</span><br><span class="line">   password = body.password;</span><br></pre></td></tr></table></figure>
<p>在ES6，我们可以使用这些语句代替上面的ES5代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; house, mouse&#125; = $(<span class="string">'body'</span>).data(); <span class="comment">// we'll get house and mouse variables</span></span><br><span class="line"><span class="keyword">var</span> &#123;jsonMiddleware&#125; = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> &#123;username, password&#125; = req.body;</span><br></pre></td></tr></table></figure>
<p>这个同样也适用于数组，非常赞的用法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [col1, col2]  = $(<span class="string">'.column'</span>),</span><br><span class="line">   [<span class="meta">line1, line2, line3, , line5</span>] = file.split(<span class="string">'n'</span>);</span><br></pre></td></tr></table></figure>
<p>我们可能需要一些时间来习惯解构赋值语法的使用，但是它确实能给我们带来许多意外的收获。</p>
<h2><span id="5enhanced-object-literals-增强的对象字面量">5.Enhanced Object Literals （增强的对象字面量）</span></h2>
<p>使用对象文本可以做许多让人意想不到的事情！通过ES6，我们可以把ES5中的JSON变得更加接近于一个类。</p>
<p>下面是一个典型ES5对象文本，里面有一些方法和属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceBase = &#123;<span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">url</span>: <span class="string">'azat.co'</span>&#125;,</span><br><span class="line">    getAccounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> accountServiceES5 = &#123;</span><br><span class="line">  port: serviceBase.port,</span><br><span class="line">  url: serviceBase.url,</span><br><span class="line">  getAccounts: getAccounts,</span><br><span class="line">   toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.valueOf());</span><br><span class="line">  &#125;,</span><br><span class="line">  getUrl: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</span><br><span class="line">  valueOf_1_2_3: getAccounts()</span><br><span class="line">&#125;<span class="comment">//欢迎加入前端全栈开发交流圈一起吹水聊天学习交流：619586920</span></span><br></pre></td></tr></table></figure>
<p>如果我们想让它更有意思，我们可以用Object.create从serviceBase继承原型的方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accountServiceES5ObjectCreate = <span class="built_in">Object</span>.create(serviceBase)</span><br><span class="line"><span class="keyword">var</span> accountServiceES5ObjectCreate = &#123;</span><br><span class="line">  getAccounts: getAccounts,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.valueOf());</span><br><span class="line">  &#125;,</span><br><span class="line">  getUrl: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</span><br><span class="line">  valueOf_1_2_3: getAccounts()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，accountServiceES5ObjectCreate 和accountServiceES5 并不是完全一致的，因为一个对象(accountServiceES5)在<strong>proto</strong>对象中将有下面这些属性：</p>
<p>为了方便举例，我们将考虑它们的相似处。所以在ES6的对象文本中，既可以直接分配getAccounts: getAccounts,也可以只需用一个getAccounts，此外，我们在这里通过<strong>proto</strong>（并不是通过’proto’）设置属性，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serviceBase = &#123;<span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">url</span>: <span class="string">'azat.co'</span>&#125;,</span><br><span class="line">getAccounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;;</span><br><span class="line"><span class="keyword">var</span> accountService = &#123;</span><br><span class="line">    __proto__: serviceBase,</span><br><span class="line">    getAccounts,</span><br></pre></td></tr></table></figure>
<p>另外，我们可以调用super防范，以及使用动态key值(valueOf_1_2_3):</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    toString() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify((<span class="keyword">super</span>.valueOf()));</span><br><span class="line">    &#125;,</span><br><span class="line">    getUrl() &#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</span><br><span class="line">    [ <span class="string">'valueOf_'</span> + getAccounts().join(<span class="string">'_'</span>) ]: getAccounts()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(accountService)</span><br></pre></td></tr></table></figure>
<p>ES6对象文本是一个很大的进步对于旧版的对象文本来说。</p>
<h2><span id="6arrow-functions箭头函数">6.Arrow Functions（箭头函数）</span></h2>
<p>这是我迫不及待想讲的一个特征，CoffeeScript 就是因为它丰富的箭头函数让很多开发者喜爱。在ES6中，也有了丰富的箭头函数。这些丰富的箭头是令人惊讶的因为它们将使许多操作变成现实，比如，</p>
<p>以前我们使用闭包，this总是预期之外地产生改变，而箭头函数的迷人之处在于，现在你的this可以按照你的预期使用了，身处箭头函数里面，this还是原来的this。</p>
<p>有了箭头函数在ES6中， 我们就不必用that = this或 self = this 或 _this = this 或.bind(this)。例如，下面的代码用ES5就不是很优雅：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">$(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  _this.sendData();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在ES6中就不需要用 _this = this：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.btn'</span>).click(<span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sendData();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不幸的是，ES6委员会决定，以前的function的传递方式也是一个很好的方案，所以它们仍然保留了以前的功能。</p>
<p>下面这是一个另外的例子，我们通过call传递文本给logUpperCase() 函数在ES5中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.string = <span class="keyword">this</span>.string.toUpperCase();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(_this.string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logUpperCase.call(&#123; <span class="attr">string</span>: <span class="string">'ES6 rocks'</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>而在ES6，我们并不需要用_this浪费时间：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.string = <span class="keyword">this</span>.string.toUpperCase();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.string);</span><br><span class="line">&#125;</span><br><span class="line">logUpperCase.call(&#123; <span class="attr">string</span>: <span class="string">'ES6 rocks'</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>请注意，只要你愿意，在ES6中=&gt;可以混合和匹配老的函数一起使用。当在一行代码中用了箭头函数，它就变成了一个表达式。它将暗地里返回单个语句的结果。如果你超过了一行，将需要明确使用return。</p>
<p>这是用ES5代码创建一个消息数组：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>];</span><br><span class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ID is "</span> + value; <span class="comment">// explicit return</span></span><br></pre></td></tr></table></figure>
<p>用ES6是这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>];</span><br><span class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="params">value</span> =&gt;</span> <span class="string">`ID is <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// implicit return</span></span><br></pre></td></tr></table></figure>
<p>请注意，这里用了字符串模板。</p>
<p>在箭头函数中，对于单个参数，括号()是可选的，但当你超过一个参数的时候你就需要他们。</p>
<p>在ES5代码有明确的返回功能：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>, <span class="string">'563295464e345e145fdf2df9'</span>];</span><br><span class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ID of '</span> + index + <span class="string">' element is '</span> + value + <span class="string">' '</span>; <span class="comment">// explicit return</span></span><br></pre></td></tr></table></figure>
<p>在ES6中有更加严谨的版本，参数需要被包含在括号里并且它是隐式的返回：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>];</span><br><span class="line"><span class="keyword">var</span> messages = ids.map(<span class="function">(<span class="params">value, index, list</span>) =&gt;</span> <span class="string">`ID of <span class="subst">$&#123;index&#125;</span> element is <span class="subst">$&#123;value&#125;</span> `</span>); <span class="comment">// implicit return</span></span><br></pre></td></tr></table></figure>
<h2><span id="7-promises">7. Promises</span></h2>
<p>Promises 是一个有争议的话题。因此有许多略微不同的promise 实现语法。Q，bluebird，deferred.js，vow,  avow, jquery  一些可以列出名字的。也有人说我们不需要promises，仅仅使用异步，生成器，回调等就够了。但令人高兴的是，在ES6中有标准的Promise实现。</p>
<p>下面是一个简单的用setTimeout()实现的异步延迟加载函数:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在ES6中，我们可以用promise重写:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait1000 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者用ES6的箭头函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait1000 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到目前为止，代码的行数从三行增加到五行，并没有任何明显的好处。确实，如果我们有更多的嵌套逻辑在setTimeout()回调函数中，我们将发现更多好处：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Wheeyee!'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在ES6中我们可以用promises重写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait1000 =  <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;setTimeout(resolve, <span class="number">1000</span>)&#125;);</span><br><span class="line">wait1000()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</span><br><span class="line">        <span class="keyword">return</span> wait1000()</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Wheeyee!'</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>还是不确信Promises 比普通回调更好？其实我也不确信，我认为一旦你有回调的想法，那么就没有必要额外增加promises的复杂性。</p>
<p>虽然，ES6 有让人崇拜的Promises 。Promises 是一个有利有弊的回调但是确实是一个好的特性，更多详细的信息关于promise:<a href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell" target="_blank" rel="noopener">Introduction to ES6 Promises</a>.</p>
<h2><span id="8block-scoped-constructs-let-and-const块作用域和构造let和const"><strong>8.Block-Scoped Constructs Let and Const（块作用域和构造let和const）</strong></span></h2>
<p>在ES6代码中，你可能已经看到那熟悉的身影let。在ES6里let并不是一个花俏的特性，它是更复杂的。Let是一种新的变量申明方式，它允许你把变量作用域控制在块级里面。我们用大括号定义代码块，在ES5中，块级作用域起不了任何作用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> amount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (vip) &#123;</span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123; <span class="comment">// more crazy blocks!</span></span><br><span class="line">    <span class="keyword">var</span> amount = <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">var</span> amount = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>结果将返回1000，这真是一个bug。在ES6中，我们用let限制块级作用域。而var是限制函数作用域。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> amount = <span class="number">0</span>; <span class="comment">// probably should also be let, but you can mix var and let</span></span><br><span class="line">  <span class="keyword">if</span> (vip) &#123;</span><br><span class="line">    <span class="keyword">let</span> amount = <span class="number">1</span>; <span class="comment">// first amount is still 0</span></span><br><span class="line">  &#125; </span><br><span class="line">  &#123; <span class="comment">// more crazy blocks!</span></span><br><span class="line">    <span class="keyword">let</span> amount = <span class="number">100</span>; <span class="comment">// first amount is still 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">let</span> amount = <span class="number">1000</span>; <span class="comment">// first amount is still 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>这个结果将会是0，因为块作用域中有了let。如果（amount=1）.那么这个表达式将返回1。谈到const，就更加容易了；它就是一个不变量，也是块级作用域就像let一样。下面是一个演示，这里有一堆常量，它们互不影响，因为它们属于不同的块级作用域:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> amount = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">if</span> (vip) &#123;</span><br><span class="line">    <span class="keyword">const</span> amount = <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  &#123; <span class="comment">// more crazy blocks!</span></span><br><span class="line">    <span class="keyword">const</span> amount = <span class="number">100</span> ;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> amount = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>从我个人看来，let 和const使这个语言变复杂了。没有它们的话，我们只需考虑一种方式，现在有许多种场景需要考虑。</p>
<h2><span id="9-classes-类">9. Classes （类）</span></h2>
<p>如果你喜欢面向对象编程（OOP），那么你将喜爱这个特性。以后写一个类和继承将变得跟在facebook上写一个评论那么容易。</p>
<p>类的创建和使用真是一件令人头疼的事情在过去的ES5中，因为没有一个关键字class （它被保留，但是什么也不能做）。在此之上，大量的继承模型像<a href="http://javascript.info/tutorial/pseudo-classical-pattern" target="_blank" rel="noopener">pseudo classical</a>, <a href="http://www.crockford.com/javascript/inheritance.html" target="_blank" rel="noopener">classical</a>, <a href="http://javascript.info/tutorial/factory-constructor-pattern" target="_blank" rel="noopener">functional</a> 更加增加了混乱，JavaScript 之间的宗教战争只会更加火上浇油。</p>
<p>用ES5写一个类，有很多种方法，这里就先不说了。现在就来看看如何用ES6写一个类吧。ES6没有用函数, 而是使用原型实现类。我们创建一个类baseModel ，并且在这个类里定义了一个constructor 和一个 getName()方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options, data) &#123; <span class="comment">// class constructor，node.js 5.6暂时不支持options = &#123;&#125;, data = []这样传参</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Base'</span>;</span><br><span class="line">    <span class="keyword">this</span>.url = <span class="string">'http://azat.co/api'</span>;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    getName() &#123; <span class="comment">// class method</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Class name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们对options 和data使用了默认参数值。此外方法名也不需要加function关键字，而且冒号(：)也不需要了。另外一个大的区别就是你不需要分配属性this。现在设置一个属性的值，只需简单的在构造函数中分配。</p>
<p>AccountModel 从类baseModel 中继承而来:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountModel</span> <span class="keyword">extends</span> <span class="title">baseModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options, data) &#123;</span><br></pre></td></tr></table></figure>
<p>为了调用父级构造函数，可以毫不费力的唤起super()用参数传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>(&#123;<span class="keyword">private</span>: <span class="keyword">true</span>&#125;, [<span class="string">'32113123123'</span>, <span class="string">'524214691'</span>]); <span class="comment">//call the parent method with super</span></span><br><span class="line">       <span class="keyword">this</span>.name = <span class="string">'Account Model'</span>;</span><br><span class="line">       <span class="keyword">this</span>.url +=<span class="string">'/accounts/'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果你想做些更好玩的，你可以把 accountData 设置成一个属性：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">get</span> <span class="title">accountsData</span>(<span class="params"></span>)</span> &#123; <span class="comment">//calculated attribute getter</span></span><br><span class="line">    <span class="comment">// ... make XHR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，你如何调用他们呢？它是非常容易的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> accounts = <span class="keyword">new</span> AccountModel(<span class="number">5</span>);</span><br><span class="line">accounts.getName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Data is %s'</span>, accounts.accountsData);</span><br></pre></td></tr></table></figure>
<p>结果令人惊讶，输出是：</p>
<p>Class name: Account Model</p>
<p>Data is 32113123123,524214691</p>
<h2><span id="10-modules-模块">10. Modules （模块）</span></h2>
<p>众所周知，在ES6以前JavaScript并不支持本地的模块。人们想出了AMD，RequireJS，CommonJS以及其它解决方法。现在ES6中可以用模块import 和export 操作了。</p>
<p>在ES5中，你可以在<code>&lt;script&gt;</code>中直接写可以运行的代码（简称IIFE），或者一些库像AMD。然而在ES6中，你可以用export导入你的类。下面举个例子，在ES5中,module.js有port变量和getAccounts 方法:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;  <span class="attr">port</span>: <span class="number">3000</span>,  <span class="attr">getAccounts</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    ...  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在ES5中，main.js需要依赖require(‘module’) 导入module.js：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> service = <span class="built_in">require</span>(<span class="string">'module.js'</span>);<span class="built_in">console</span>.log(service.port); <span class="comment">// 3000</span></span><br></pre></td></tr></table></figure>
<p>但在ES6中，我们将用export and import。例如，这是我们用ES6 写的module.js文件库：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> port = <span class="number">3000</span>;<span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccounts</span>(<span class="params">url</span>) </span>&#123;  ...&#125;</span><br></pre></td></tr></table></figure>
<p>如果用ES6来导入到文件main.js中，我们需用import {name} from ‘my-module’语法，例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;port, getAccounts&#125; <span class="keyword">from</span> <span class="string">'module'</span>;<span class="built_in">console</span>.log(port); <span class="comment">// 3000</span></span><br></pre></td></tr></table></figure>
<p>或者我们可以在main.js中把整个模块导入, 并命名为 service：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> service <span class="keyword">from</span> <span class="string">'module'</span>;<span class="built_in">console</span>.log(service.port); <span class="comment">// 3000</span></span><br></pre></td></tr></table></figure>
<p>从我个人角度来说，我觉得ES6模块是让人困惑的。但可以肯定的事，它们使语言更加灵活了。</p>
<p>并不是所有的浏览器都支持ES6模块，所以你需要使用一些像jspm去支持ES6模块。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript    </a></div><div class="post_share"><div class="social-share" data-image="/images/header_img/header-1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/29/java/java-threadpoolexecutor-introduce/"><img class="prev_cover lozad" data-src="/images/header_img/header-8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Java线程池ThreadPoolExecutor入门</span></div></a></div><div class="next-post pull-right"><a href="/2019/08/07/front/html5-new-feature/"><img class="next_cover lozad" data-src="/images/header_img/header-10.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>HTML5新特性</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span>Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/08/07/front/html5-new-feature/" title="HTML5新特性"><img class="relatedPosts_cover lozad" data-src="/images/header_img/header-10.jpg"><div class="relatedPosts_title">HTML5新特性</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Liu Ning</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>